// biotSavartLaw.cc --- 
// 
// Filename: biotSavartLaw.cc
// Description: 
// 
// Author:    Yu Lu
// Email:     yulu@utexas.edu
// Github:    https://github.com/SuperYuLu 
// 
// Created: Sat Aug 11 21:16:24 2018 (-0500)
// Version: 
// Last-Updated: Sun Aug 26 12:55:31 2018 (-0500)
//           By: yulu
//     Update #: 470
// 

#include "biotSavartLaw.h" 

BiotSavartLaw :: BiotSavartLaw(void){
  //public
  wires = {};
  mesh = 0;
  current = 0.0;
  magField = {};

  //private
  ptr_IdL = 0;
  ptr_R = 0;
  selectedField = {};
}

BiotSavartLaw :: BiotSavartLaw(const Wire* ptrWireObj, const Mesh* meshObj, double current_value){
  // input parameters
  wires.push_back(ptrWireObj);
  mesh = meshObj;
  current = current_value;

  // private parameters
  ptr_IdL = IdL();
  ptr_R = R();

  // result parameters
  magField = {};
}


void BiotSavartLaw :: addWires(const Wire *wireObj){wires.push_back(wireObj);}


void BiotSavartLaw :: clearWires(void){wires.clear();};


const vectorList* BiotSavartLaw :: IdL(void){ // generate elementIdL values 
  static vectorList IdL;
  vectorList :: const_iterator iterVL;
  std::list<const Wire*> ::const_iterator iterWires = wires.cbegin();

  IdL.clear();
  
  while(iterWires != wires.cend()){

    if(!((*iterWires) -> discretized)){ // wires has to be discretized first
      std::cerr << "Wire path not discretized, abort !" << std::endl;
      break;}
    
    else if(((*iterWires) -> path).size() < 2){ // need at leasest two points 
      std::cerr << "There must be at least two point in the discretized path, abort !" << std::endl;
      break;}

    else{
      for(iterVL = ((*iterWires) -> path).cbegin(); iterVL != std::prev(((*iterWires) -> path).cend()); iterVL ++){
	IdL.push_back((*std::next(iterVL) - *iterVL) * current);}}
    
    iterWires ++;
  }
  
  return &IdL;
}

const vectorList* BiotSavartLaw :: R(void){  // element wire center cooordinates
  static vectorList R = {};
  vectorList :: const_iterator iterElemWire;
  std::list<const Wire*> ::const_iterator iterWires = wires.cbegin();
  
  R.clear();
    
  while(iterWires != wires.cend()){ // go through all wire objects in the list
    
    if(!((*iterWires) -> discretized)){ // wires has to be discretized first
      std::cerr << "Wire path not discretized, abort !" << std::endl;
      break;}
    
    else if(((*iterWires) -> path).size() < 2){ // need at leasest two points 
      std::cerr << "There must be at least two point in the discretized path, abort !" << std::endl;
      break;}
    
    else{
      for(iterElemWire = ((*iterWires) -> path).cbegin(); iterElemWire != std::prev(((*iterWires) -> path).cend()); iterElemWire ++){
	R.push_back((*std::next(iterElemWire) + *iterElemWire) * 0.5);}}
    
    iterWires ++;
  }
  
  return &R;
}

    



std::vector<double> BiotSavartLaw :: singlePointField (const std::vector<double> &r){
  // calculate magnetic field at single point r generated by discretized current unit list
  // IdL at position list R. 
  double rNorm;
  const double prefix = 1e-7;
  std::vector<double> field = {0, 0, 0};
  std::vector<double> r3;
  

  if(ptr_IdL == 0 || ptr_R == 0){// make sure unit vectors are initialized 
    ptr_IdL = IdL();
    ptr_R = R();}

  vectorList::const_iterator iterIdL = ptr_IdL -> cbegin();
  vectorList::const_iterator iterR = ptr_R -> cbegin();
  
  while(iterIdL != ptr_IdL -> cend() && iterR != ptr_R -> cend()){
    rNorm = l2_norm(r - *iterR);
    r3 = (r - *iterR) / (rNorm * rNorm * rNorm);
    field = field + prefix * crossProduct(*iterIdL, r3);
    iterIdL ++;
    iterR ++;}
  
  return field;
}

void BiotSavartLaw :: calculate(void){
  // Evaluate field values at given meshgrid points
  vectorList field((mesh -> meshgrid).size());
  vectorList::const_iterator meshIter = (mesh -> meshgrid).cbegin();
  vectorList::iterator fieldIter;

  std::cout << "Evaluating magnetic field at mesh points..." << std::endl;

  // Initialize all field values to be 0
  for(fieldIter = field.begin(); fieldIter != field.end(); fieldIter++){
    *fieldIter = std::vector<double>({0, 0, 0});}
  
  // Reset fieldIter to point to head
  fieldIter = field.begin();
  
  while(meshIter != (mesh -> meshgrid).cend()){
    *fieldIter = *fieldIter + singlePointField(*meshIter);
    meshIter ++;
    fieldIter ++;}

  magField = field;
}



void BiotSavartLaw :: filterAxisField(vectorList& grid,vectorList& field, char axis, double value){
  int colIdx;
  double maxDiff;
  vectorList :: const_iterator pGrid;
  vectorList :: const_iterator pField;
  vectorList tempField;
  vectorList tempGrid;

  pGrid = grid.begin();
  pField = field.begin();
  maxDiff = l2_norm(*pGrid - (*std::next(pGrid))) / 2.0; // max diff during search

  switch(axis){
  case 'x': colIdx = 0; break;
  case 'y': colIdx = 1; break;
  case 'z': colIdx = 2; break;
  default:
    std::cerr << "Axis not understand, options: 'x', 'y', 'z'" << std::endl;}

  while(pGrid != grid.end()){
    if(std :: abs((*pGrid)[colIdx] - value) < maxDiff){
      tempGrid.push_back(*pGrid);
      tempField.push_back(*pField);}
    pGrid++;
    pField++;}
  
  if(tempField.empty()){
    std::cout << axis << " = " << value << " not found in the mesh" << std::endl;}
  
  else{
    field = tempField;
    grid = tempGrid;}
  
}


void BiotSavartLaw :: startAnalysis(void){
  // make hard copy of field and mesh to start a new analysis
  std::cout << "Start result field analysis..." << std::endl;
  
  selectedField = magField; 
  selectedMesh = mesh -> meshgrid;
}

void BiotSavartLaw :: sliceMeshX(double x){
  filterAxisField(selectedMesh, selectedField, 'x', x);
}

void BiotSavartLaw :: sliceMeshY(double y){
  filterAxisField(selectedMesh, selectedField, 'y', y);
}

void BiotSavartLaw :: sliceMeshZ(double z){
  filterAxisField(selectedMesh, selectedField, 'z', z);
}


std::list<double> BiotSavartLaw :: uniqueGrid(char axis, const vectorList& grid){
  // Find the uniqte grid values along certain axis (x, y, z)
  // This assume the original grid is generated in the low to high order
  std::list<double> uGrid;
  int colIdx = -1;

  switch(axis){
  case 'x': colIdx = 0; break;
  case 'y': colIdx = 1; break;
  case 'z': colIdx = 2; break;
  default:
    std::cerr << "Axis not understand, options: 'x', 'y', 'z'" << std::endl;}

  for(auto t : grid){

    if(uGrid.empty()){uGrid.push_back(t[colIdx]);}
    else if(std::find(uGrid.begin(), uGrid.end(), t[colIdx]) == uGrid.end()){
      uGrid.push_back(t[colIdx]);}
    else{} }
  
  return uGrid;
}


void BiotSavartLaw :: normField(void){
  // Calculate the absolute value of field vector list 'selectedField'
  vectorList :: iterator iterField;
  
  for(iterField = selectedField.begin(); iterField != selectedField.end(); iterField++){
    *iterField = std::vector<double>({l2_norm(*iterField)});}
}


void BiotSavartLaw :: saveAsCSV(void){
  // Save field and coordinates as csv file
  vectorList combinedVectList;
  std::vector<double> combinedVector;
  vectorList :: iterator pGrid;
  vectorList :: iterator pField;
  
  pGrid = selectedMesh.begin();
  pField = selectedField.begin();

  while(pGrid != selectedMesh.end()){
    combinedVector = *pGrid;
    combinedVector.insert(combinedVector.end(),pField -> begin(), pField -> end());
    combinedVectList.push_back(combinedVector);
    pGrid++;
    pField++;}

  if(selectedField.front().size() > 1){ // There are 3 component of mag field
      std :: string filename = "x_y_z_Bx_By_Bz.csv";
      std::ofstream f(filename, std::ios::out);
      f << "x," << "y," << "z,"
	<< "Bx," << "By," << "Bz" << std::endl; //gnuplot comment
      writeVectorList(f, combinedVectList);
      f.close();
      std::cout << "Analysis result save in " << filename << std::endl;}
    
  else{ // Only one component of mag field (normalized)
    std :: string filename = "x_y_z_Babs.csv";
    std::ofstream f(filename, std::ios::out);
    f << "x," << "y," << "z," << "Babs" << std::endl;
    writeVectorList(f, combinedVectList);
    f.close();
    std::cout << "Analysis result save in " << filename << std::endl;}
  
}
