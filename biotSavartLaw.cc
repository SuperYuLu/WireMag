// biotSavartLaw.cc --- 
// 
// Filename: biotSavartLaw.cc
// Description: 
// 
// Author:    Yu Lu
// Email:     yulu@utexas.edu
// Github:    https://github.com/SuperYuLu 
// 
// Created: Sat Aug 11 21:16:24 2018 (-0500)
// Version: 
// Last-Updated: Tue Aug 14 15:35:57 2018 (-0500)
//           By: yulu
//     Update #: 105
// 

#include <iostream>
#include "biotSavartLaw.h"

BiotSavartLaw :: BiotSavartLaw(void){}


BiotSavartLaw :: BiotSavartLaw(const Wire* wireObj){wires.push_back(wireObj);}


void BiotSavartLaw :: addWires(const Wire *wireObj){wires.push_back(wireObj);}


void BiotSavartLaw :: clear(void){wires.clear();};


std::vector<double> BiotSavartLaw::crossProduct(const std::vector<double> &x,
						const std::vector<double> &y) const{
  std::vector<double> product = {x[2] * y[3] - x[3] * y[2],
				 x[1] * y[3] - x[3] * y[1],
				 x[1] * y[2] - x[2] * y[1]};
  return product;
}


std::vector<double> BiotSavartLaw :: singlePointBField (const std::vector<double> &r,
						       const vectorList &IdL,
						       const vectorList &R) const{
  // calculate magnetic field at single point r generated by discretized current unit list
  // IdL at position list R. 
  double rNorm;
  const double prefix = 1e-7;
  std::vector<double> field = {0, 0, 0};
  std::vector<double> r3;
  vectorList::const_iterator iterIdL = IdL.cbegin();
  vectorList::const_iterator iterR = R.cbegin();
  
  while(iterIdL != IdL.cend() && iterR != R.cend()){
    rNorm = l2_norm(r - *iterR);
    r3 = (r - *iterR) / (rNorm * rNorm * rNorm);
    field = field + prefix * crossProduct(*iterIdL, r3);
    iterIdL ++;
    iterR ++;
  }
  
  return field;
}


vectorList* BiotSavartLaw:: calculateBField(const vectorList &points) const{
  static vectorList field(points.size());
  std::list<const Wire*> ::const_iterator wireIter = wires.cbegin();
  vectorList::const_iterator pointsIter = points.cbegin();
  vectorList::iterator fieldIter;
  IdL_R IdLR;

  // Initialize all field values to be 0
  for(fieldIter = field.begin(); fieldIter != field.end(); fieldIter++){
    *fieldIter = std::vector<double>({0, 0, 0});
  }

  // Reset fieldIter to point to head
  fieldIter = field.begin();
  
  while(wireIter != wires.cend()){
    IdLR =(*wireIter) -> elementIdLR();
    while(pointsIter != points.cend() && fieldIter != field.end()){
      *fieldIter = *fieldIter + singlePointBField(*pointsIter, IdLR.IdL, IdLR.R);
      pointsIter ++;
      fieldIter ++;
    }
    wireIter ++;
  }
  return &field;
}
