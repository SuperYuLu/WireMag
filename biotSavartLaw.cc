// biotSavartLaw.cc --- 
// 
// Filename: biotSavartLaw.cc
// Description: 
// 
// Author:    Yu Lu
// Email:     yulu@utexas.edu
// Github:    https://github.com/SuperYuLu 
// 
// Created: Sat Aug 11 21:16:24 2018 (-0500)
// Version: 
// Last-Updated: Mon Aug 20 23:16:03 2018 (-0500)
//           By: yulu
//     Update #: 228
// 

#include <iostream>
#include <algorithm>   // std::prev()
#include "biotSavartLaw.h"

 
BiotSavartLaw :: BiotSavartLaw(void){
  wires = std::list<const Wire*>({});
  mesh = 0;
  current = 0.0;
  ptr_IdL = 0;
  ptr_R = 0;
}

BiotSavartLaw :: BiotSavartLaw(const Wire* ptrWireObj, const Grid* gridObj, double current_value){
  wires.push_back(ptrWireObj);
  mesh = gridObj;
  current = current_value;
  ptr_IdL = IdL();
  ptr_R = R();
}


void BiotSavartLaw :: addWires(const Wire *wireObj){wires.push_back(wireObj);}


void BiotSavartLaw :: clearWires(void){wires.clear();};



const vectorList* BiotSavartLaw :: IdL(void){
  static vectorList IdL;
  vectorList :: const_iterator iterVL;
  std::list<const Wire*> ::const_iterator iterWires = wires.cbegin();
  
  while(iterWires != wires.cend()){
    if(!((*iterWires) -> discretized)){ // wires has to be discretized first
      std::cerr << "Wire path not discretized, abort !" << std::endl;
      
      break;
    }else if(((*iterWires) -> path).size() < 2){ // need at leasest two points 
      std::cerr << "There must be at least two point in the discretized path, abort !" << std::endl;
      break;
    }else{
      for(iterVL = ((*iterWires) -> path).cbegin(); iterVL != std::prev(((*iterWires) -> path).cend()); iterVL ++){
	IdL.push_back((*std::next(iterVL) - *iterVL) * current);
      }
    }
    iterWires ++;
    
  }
  return &IdL;
}


const vectorList* BiotSavartLaw :: R(void){
  static vectorList R = {};
  vectorList :: const_iterator iterVL;
  std::list<const Wire*> ::const_iterator iterWires = wires.cbegin();
  
  while(iterWires != wires.cend()){
    if(!((*iterWires) -> discretized)){ // wires has to be discretized first
      std::cerr << "Wire path not discretized, abort !" << std::endl;
      break;
    }else if(((*iterWires) -> path).size() < 2){ // need at leasest two points 
      std::cerr << "There must be at least two point in the discretized path, abort !" << std::endl;
      break;
    }else{
      for(iterVL = ((*iterWires) -> path).cbegin(); iterVL != std::prev(((*iterWires) -> path).cend()); iterVL ++){
	R.push_back((*std::next(iterVL) + *iterVL) * 0.5);
      }
    }
    iterWires ++;
  }
  return &R;
}

    


std::vector<double> BiotSavartLaw::crossProduct(const std::vector<double> &x,
						const std::vector<double> &y){
  std::vector<double> product = {x[1] * y[2] - x[2] * y[1],
				 x[0] * y[2] - x[2] * y[0],
				 x[0] * y[1] - x[1] * y[0]};
  return product;
}


std::vector<double> BiotSavartLaw :: singlePointBField (const std::vector<double> &r){
  // calculate magnetic field at single point r generated by discretized current unit list
  // IdL at position list R. 
  double rNorm;
  const double prefix = 1e-7;
  std::vector<double> field = {0, 0, 0};
  std::vector<double> r3;

  if(ptr_IdL == 0 || ptr_R == 0){
    // make sure unit vectors are initialized 
    ptr_IdL = IdL();
    ptr_R = R();
  }
  
  vectorList::const_iterator iterIdL = ptr_IdL -> cbegin();
  vectorList::const_iterator iterR = ptr_R -> cbegin();

  while(iterIdL != ptr_IdL -> cend() && iterR != ptr_R -> cend()){
    rNorm = l2_norm(r - *iterR);
    r3 = (r - *iterR) / (rNorm * rNorm * rNorm);
    field = field + prefix * crossProduct(*iterIdL, r3);
    iterIdL ++;
    iterR ++;
  }
  
  return field;
}


vectorList* BiotSavartLaw:: meshGridBField(void){
  
  //std::cout << "yes" << std::endl;
  //std::cout << (*mesh).grid.size() << std::endl;
  static vectorList field((mesh -> grid).size());
  
  std::list<const Wire*> ::const_iterator wireIter = wires.cbegin();
  vectorList::const_iterator gridIter = (mesh -> grid).cbegin();
  vectorList::iterator fieldIter;
  
  
  // Initialize all field values to be 0
  for(fieldIter = field.begin(); fieldIter != field.end(); fieldIter++){
    *fieldIter = std::vector<double>({0, 0, 0});
  }

  // Reset fieldIter to point to head
  fieldIter = field.begin();
  
  while(wireIter != wires.cend()){
    
    while(gridIter != (mesh -> grid).cend() && fieldIter != field.end()){
      *fieldIter = *fieldIter + singlePointBField(*gridIter);
      gridIter ++;
      fieldIter ++;
    }
    
    wireIter ++;
  }
  return &field;
}

